#!/usr/bin/env bash
set -e

openai_api_url="${OPENAI_API_URL:=https://openrouter.ai/api}"
openai_api_key="${OPENAI_API_KEY:=$(secret-tool lookup git-ez openai-api-key)}"
seed="${SEED:=$RANDOM}"

if [ -z "$OPENAI_API_KEY" ] && [ -z "$openai_api_key" ]; then
  echo "[error]: please provide an api key in the env variable OPENAI_API_KEY" >&2
  exit 1
elif [ ! -z "$OPENAI_API_KEY" ] && [ -z "$openai_api_key" ]; then
  openai_api_key="$OPENAI_API_KEY"
  echo "$openai_api_key" | secret-tool store --label='git-ez: OpenAI API key' git-ez openai-api-key
fi

if echo "$*" | grep -Eq "(-h|--help)"; then
  echo "usage: git-ez 'feat: I rewrited the project in rust for fun and profit'" >&2
  exit 0
fi

with_staged=""
if echo "$*" | grep -Eq "(-s|--staged)"; then
    with_staged=" --staged "
fi

system_prompt=$(cat <<-'EOF'
You are a commit assistant writer.
The user send you a git diff and an optional context (prioritize the diff, it's here mainly to help understand the diff) and you help him write the commit message.
You respect conventional commits 1.0.0 for commit type using:
- `feat:` for features (this correlates with MINOR in Semantic Versioning);
- `fix:` for bug fixes (this correlates with PATCH in Semantic Versioning);
- `BREAKING CHANGE:` or appends a ! after the type, introduces a breaking API change (correlating with MAJOR in Semantic Versioning);
- `style:` for changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, linter errors, etc);
- `refactor:` for changes that neither fixes a bug nor adds a feature;
- `docs:` for changes affecting only the documentation;
- `build:` for changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm);
- `ci:` for changes to the CI configuration files and scripts;
- `test:` for changes adding missing tests or correcting existing tests;

Recommandation for the commit message:
- Keep the message short: Makes the list of commits more readable (~50 chars).
- Start the commit message with a **lowercased** action verb at past participle.
- Think about your future self/colleages: It's important for the reader to understand what happened.
- Think about the CHANGELOG: The commits will may end up in the changelog, so try writing for it.
- Keep some precision: Try to be precise in the commit message if it's a config value that changed.

You must respond only the full commit message (3 propositions) and then their included files (split in as much commits as needed but the files can only be in one commit):
```
feat: <commit message>
feat: <variation of commit message>
feat: <another proposition of commit message>
    - ./file/that/changed.txt
    - ./another/file/in-the-commit.txt
fix: <commit message 2>
fix: <variation of commit message 2>
fix: <another proposition of commit message 2>
    - ./file/that/changed2.txt
```

If the diff is empty and no user context is provided return an error.
EOF
)

user_prompt="$(echo "User context:\n $*\n\nCommit diff:\n" '```'"\n$(git diff $with_staged . | sed 's/"/\\"/g')\n"'```')"

# echo '{
# "model": "'"${OPENAI_MODEL:=google/gemini-2.5-flash}"'",
# "temperature": 0.5,
# "seed": '$seed',
# "messages": [
#   {"role": "system", "content": "'"$(echo "$system_prompt" | sed -z 's/\n/\\n/g')"'"},
#   {"role": "user", "content": "'"$(echo "$user_prompt" | sed -z 's/\n/\\n/g')"'"}
# ]
# }'

curl --silent "$openai_api_url/v1/chat/completions" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $openai_api_key" \
  -d '{
  "model": "'"${OPENAI_MODEL:=google/gemini-2.5-flash}"'",
  "temperature": 0.5,
  "seed": '$seed',
  "messages": [
    {"role": "system", "content": "'"$(echo "$system_prompt" | sed -z 's/\n/\\n/g')"'"},
    {"role": "user", "content": "'"$(echo "$user_prompt" | sed -z 's/\n/\\n/g')"'"}
  ]
}' | jq -r '.choices[0].message.content' | sed -E 's/(`|\\n)//g'
